
+--
	同步，可以理解为在执行完一个函数或方法之后，一直等待系统（这里可以理解成内核）返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 
+--
	异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程
+--
	对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。

+--
	同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行（死心眼）。 
	异步在一定程度上可以看做是多线程的（废话，一个线程怎么叫异步），请求一个方法后，就不管了，继续执行其他的方法。
+--
	I/O 多路复用技术是 为了解决进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程不阻塞于某个特定的 I/O 系统调用。
+--
	select()，poll()，epoll()都是I/O多路复用的机制。
+--
	I/O多路复用通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪，就是这个文件描述符进行读写操作之前），能够通知程序进行相应的读写操作。
+--
	select()，poll()，epoll()本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个 读写过程是阻塞的，
	而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
+--
	与多线程和多进程相比，I/O 多路复用的最大优势是系统开销小，系统不需要建立新的进程或者线程，也不必维护这些线程和进程。
+--
	文件描述符fd(File descriptor)
	文件描述符简称fd。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表，用以标明每一个被进程所打开的文件和socket。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。第一个打开的文件是0，第二个是1，依此类推。读写文件也需要使用文件描述符来指定待读写的文件。Unix 操作系统通常给每个进程能打开的文件数量强加一个限制。
	在Windows操作系统上，文件描述符被称作 文件句柄(指针)。Windows服务器打开文件的句柄极限设置为16,384。此数量可以在任务管理器的性能摘要中监视。

+--
	linux下，文件描述符分为“用户级限制”和“系统级限制”

	每个用户登录后执行的程序占用文件描述符的总数
	1001   lsof -u www | wc -l
    	   lsof -u data0 | wc -l
    本次登录的session其文件描述符的限制
 	1004   ulimit -n
 	1005  cat /etc/security/limits.conf

 	查看系统级限制
 	1006  sysctl -a | grep fs.file-max
 	1007  cat /etc/sysctl.conf

+--
	函数定义
	int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
	select()系统调用--监视并等待多个文件描述符的属性变化（可读、可写或错误异常）。
		     select()函数返回后，可以通过遍历 fdset，来找到就绪的描述符
		参数
			nfds: 要监视的文件描述符的范围
			readfd: 监视的可读描述符集合，只要有文件描述符即将进行读操作，这个文件描述符就存储到这。
			writefds: 监视的可写描述符集合。
			exceptfds: 监视的错误异常描述符

    select()的缺点在于：
	1）每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大，同时每次调用 select() 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大。
	2）单个进程能够监视的文件描述符的数量存在最大限制，在 linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。

+--
	select() 和 poll() 系统调用的本质一样,前者在 BSD UNIX 中引入的，后者在 System V 中引入的。
	在本质上没有多大差别,管理多个描述符也是进行轮询，根据描述符的状态进行处理，
	但是 poll() 没有最大文件描述符数量的限制（但是数量过大后性能也是会下降）。
	poll() 和 select() 同样存在一个缺点就是，包含大量  文件描述符的数组被整体复制于 用户态和内核的地址空间之间 ，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大

	函数定义
	int poll(struct pollfd *fds, nfds_t nfds, int timeout);
	poll() 功能：
		监视并等待多个文件描述符的属性变化。

	参数
	fds: 不同与 select() 使用三个位图来表示三个 fdset 的方式，poll() 使用一个 pollfd 的指针实现
	pollfd 结构体数组，其中包括了你想测试的 文件描述符和事件, 事件由结构中事件域 events 来确定，调用后实际发生的时间将被填写在结构体的 revents 域。
	struct pollfd{
	int fd;         /* 文件描述符 */
	short events;   /* 等待的事件 */
	short revents;  /* 实际发生了的事件 */
	}; 

	nfds: 用来指定第一个参数数组元素个数。
	timeout: 指定等待的毫秒数

	总结
	poll() 的实现和 select() 非常相似，只是描述 fd 集合的方式不同，poll() 使用 pollfd 结构而不是 select() 的 fd_set 结构，其他的都差不多。

+--
	epoll 是在 2.6 内核中提出的，是之前的 select() 和 poll() 的增强版本。相对于 select() 和 poll() 来说，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。

	函数定义
	epoll 操作过程需要三个接口
	#include <sys/epoll.h>  
	int epoll_create(int size);  
	int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  
	int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);  


+--
	epoll 的优点主要是一下几个方面：
	1）监视的描述符数量不受限制，它所支持的 FD 上限是最大可以打开文件的数目，这个数字一般远大于 2048,举个例子,在 1GB 内存的机器上大约是 10 万左右，具体数目可以 cat /proc/sys/fs/file-max 察看,一般来说这个数目和系统内存关系很大。select() 的最大缺点就是进程打开的 fd 是有数量限制的。这对于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache 就是这样实现的)，不过虽然 Linux 上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。

	2）I/O 的效率不会随着监视 fd 的数量的增长而下降。select()，poll() 实现需要自己不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 其实也需要调用 epoll_wait() 不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在 epoll_wait() 中进入睡眠的进程。虽然都要睡眠和交替，但是 select() 和 poll() 在“醒着”的时候要遍历整个 fd 集合，而 epoll 在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的 CPU 时间。这就是回调机制带来的性能提升。

	3）select()，poll() 每次调用都要把 fd 集合从用户态往内核态拷贝一次，而 epoll 只要一次拷贝，这也能节省不少的开销。
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--
+--



