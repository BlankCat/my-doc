Linux网络IO模型

https://my.oschina.net/u/2939155/blog/906516
用户空间 | 内核空间 |
缓冲区	 | 缓冲器   |磁盘控制器--磁盘
进程


计算机是由一堆硬件组成的，操作系统是为了有效的控制这些硬件资源的软件。
操作系统除了有效地控制这些硬件资源的分配，并提供计算机运行所需要的功能之外，
为了提供程序员更容易开发软件的环境，操作系统还提供了一整组系统调用接口。

---
https://my.oschina.net/victorlovecode/blog/344290
应用程序
系统呼叫（系统调用）
核心（内核）
硬件

----
最中间的是硬件，
操作系统是由内核和系统调用接口组成，
其中内核是直接操作硬件的，
内核提供了对这些硬件资源的控制和进程管理，
系统调用接口向上提供了统一的调用接口方便开发人员调用。
最上层就是应用程序，
在应用程序中调用系统接口就能实现对硬件的操作。
----

Linux I/O系统

应用层：【目录树】

内核层：【虚拟文件系统（vfs）、JFFS2、YAFFS、Ramfs】

底层驱动：【MTD字符设备、MTD块设备、MTD设备驱动】
硬件层：【NOR FLASH 、NAND FLASH 、各种硬件】

注：
内核层有一个虚拟文件系统，就是使用标准的c类库封装的api,所以我们要操作文件系统只需要调用这里的api即可。
----
用户空间：
		应用程序
		文件
内核空间：
		VFS/FS
		总线
		驱动
		硬件

----
1、打开文件
	一个应用程序通过要求内核打开相应的文件，宣告他要访问一个I/O设备，内核返回一个非负整数，叫描述符号（Descriptor）【文件唯一标识】
2、读写文件
	读：从文件拷贝n>0个字节到存储器（内存）
	写：从存储器（内存）拷贝n>0个字节到文件
3、改变文件位置
4、关闭文件
	对于内核而言，所有打开文件都由文件描述符引用。
	文件描述符是一个非负整数。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符。当读写一个文件时，用open或create返回的文件描述符fd标识该文件，将其作为参数传送给read或write.而流(如: fopen)返回的是一个FILE结构指针, FILE结构是包含有文件描述符的，FILE结构函数可以看作是对fd直接操作的系统调用的封装, 它的优点是带有I/O缓存


Linux支持各种各样的文件系统格式，如ext2、ext3、reiserfs、FAT、NTFS、iso9660等等，不同的磁盘分区、光盘或其它存储设备都有不同的文件系统格式，然而这些文件系统都可以mount到某个目录下，使我们看到一个统一的目录树，各种文件系统上的目录和文件我们用ls命令看起来是一样的，读写操作用起来也都是一样的，这是怎么做到的呢？Linux内核在各种不同的文件系统格式之上做了一个抽象层，使得文件、目录、读写访问等概念成为抽象层的概念，因此各种文件系统看起来用起来都一样，这个抽象层称为虚拟文件系统（VFS，Virtual Filesystem）


---------------------------------------------------------------------------------------------------


操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚拟空间划分为两个部分，
一个部分为内核空间，一部分为用户空间。

网络IO的本质就是socket的读取，
socket在linux系统被抽象为流，
IO可以理解为对流的操作。

对于一次IO访问（以read为例）
数据会先被拷贝到操作系统内核的缓冲区，
然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间中。

经历两个阶段：
第一个阶段：等待数据准备
第二个阶段：将数据从内核拷贝到进程中


对于socket流而言：

第一步：通常涉及等待网络上的数据分组到达，然后复制到内核的某个缓冲区。
第二步：把数据从内核缓冲区复制到应用进程缓冲区。

当然，如果内核空间的缓冲区中已经有数据了，那么就可以省略第一步。
至于为什么不能直接让磁盘控制器把数据送到应用程序的地址空间中呢？最简单的一个原因就是应用程序不能直接操作底层硬件。



网络应用需要处理的无非就是两大类问题，
网络IO，数据计算。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。


基本概念再认识
同步/异步/阻塞/非阻塞

五种IO模型
阻塞IO模型/非阻塞IO模型/IO复用模型/信号驱动IO模型/异步IO模型


