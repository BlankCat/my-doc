
数据库隔离级别
序列化级别有什么优缺点
https://www.jianshu.com/p/4e3edbedb9a8
https://tech.meituan.com/innodb-lock.html
http://www.cnblogs.com/zhoujinyi/p/3437475.html



一、事务的基本要素（ACID）
1、原子性（Atomicity）：
	事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。
	事务执行过程中出错，会回滚到事务开始前的状态，
	所有的操作就像没有发生一样。
	也就是说事务是一个不可分割的整体，
	就像化学中学过的原子，是物质构成的基本单位。

2、一致性（Consistency）：
	事务开始前和结束后，数据库的完整性约束没有被破坏 。
	比如A向B转账，不可能A扣了钱，B却没收到。

 3、隔离性（Isolation）：
 	同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。
 	比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

 4、持久性（Durability）：
 	事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。




二、事务的并发问题
1、脏读：
		事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2、不可重复读：
		事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，
		导致事务A多次读取同一数据时，结果 不一致。
3、幻读：
		系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，
		但是系统管理员B就在这个时候插入了一条具体分数的记录，
		当系统管理员A改结束后发现还有一条记录没有改过来，
		就好像发生了幻觉一样，这就叫幻读。

小结：
	不可重复读的和幻读很容易混淆，
	不可重复读侧重于修改，
	幻读侧重于新增或删除。
	解决不可重复读的问题只需锁住满足条件的行，
	解决幻读需要锁表

三、MySQL事务隔离级别

事务隔离级别					脏读	不可重复读	幻读
读未提交（read-uncommitted）	是		是			是
不可重复读（read-committed）	否		是			是
可重复读（repeatable-read）		否		否			是
串行化（serializable）			否		否			否





事务隔离级别（ibm技术文章）
https://www.ibm.com/support/knowledgecenter/zh/SSZJPZ_9.1.0/com.ibm.swg.im.iis.conn.drs.doc/topics/DRS040.html

数据库读取行
或者
将行写入数据库的阶段
指定事务隔离级别

据锁定来指定事务类型，
该锁定从事务所影响的数据库对象上获取并且代表阶段的事务持续时间。


动态关系阶段提供一个通用事务隔离级别列表，
这些级别内部映射到后端数据库系统支持的对应隔离级别


动态关系阶段中支持的事务隔离级别为：

Read Uncommitted
事务可以看到其他事务尚未提交的更改。这些称为脏读

Read Committed
事务无法看到其他事务尚未提交的更改。因此，不支持脏读。
如果在同一事务中第二次执行相同的语句，那么在当前事务启动后可以看到其他事务已提交的行更改。
如果在同一事务中两次执行相同的语句，那么可以检索到具有不同值的行。这些被称为不可重复读取。
此隔离方式也不会阻止幻像读取。当两次执行相同语句并且第二个语句访存其他事务已插入并提交的其他行时，发生幻像读取。

Repeatable Read
类似于 Read Committed 隔离级别，但在当前事务中执行的语句不会看到其他事务提交的更改。这意味着不支持不可重复读。
支持幻像读取。

Serializable
类似于 Repeatable Read 隔离级别，但禁止幻像读取。
这是根据事务访问的数据库对象上获取的锁定进行的最严格的隔离级别。它在损失事务并行的情况下，强制执行事务中的一致性。

总结：
	串行化保证事务提交数据的强一致性，每次会锁住整张表
	但在实际开发中会选择，read Committed，它能够避免脏读取，而且具有较好的并发性能
	尽管它会导致不可重复读、幻读这些并发问题，
	在可能出现这类问题的个别场合，
	可以由应用程序采用悲观锁或乐观锁来控制
补充：
　　1、SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异
　　2、mysql中默认事务隔离级别是可重复读时并不会锁住读取到的行
　　3、事务隔离级别为读提交时，写数据只会锁住相应的行
　　4、事务隔离级别为可重复读时，写数据会锁住整张表
　　5、事务隔离级别为串行化时，读写数据都会锁住整张表
　　6、隔离级别越高，越能保证数据的完整性和一致性，
		但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，
		可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。
		尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。







五分钟搞清楚MySQL事务隔离级别

创建表，数据库存储引擎必须设置为InnoDB
首先创建一个表account。
创建表的过程略过
（由于InnoDB存储引擎支持事务，
所以将表的存储引擎设置为InnoDB）


desc account;
插入两条数据

一. read uncommitted（读取未提交数据）
	我们将事务隔离级别设置为read uncommitted，
	即便是事务没有commit，
	但是我们仍然能读到未提交的数据，
	这是所有隔离级别中最低的一种


	那么这么做有什么问题吗？
	我们在一个事务中可以随随便便读取到其他事务未提交的数据，
	这还是比较麻烦的，我们叫脏读
	实际上我们的数据改变了吗？
	答案是没有，因为只有事务commit后才会更新到数据库。



	具体用户A的操作如下：
	set session transaction isolation level read uncommitted；
	start transaction;
	select * from account;
	用户B的操作如下：
	set session transaction isolation level read uncommitted；
	start transaction;
	update account set account=account+200 where id = 1;



二. read committed（可以读取其他事务提交的数据）---大多数数据库默认的隔离级别
	当我们将当前会话的隔离级别设置为read committed的时候，
	当前会话只能读取到其他事务提交的数据，
	未提交的数据读不到。

	那么这么做有什么问题吗？
	我们在会话B同一个事务中，读取到两次不同的结果。
	这就造成了不可重复读，
	就是两次读取的结果不同。
	这种现象叫不可重复读。



	事务隔离级别设置为read commited
	A所在的会话中我们执行下面操作：
	update account set account=account-200 where id=1;

	在B用户所在的会话中查询：
	select * from account；

	A中我们将事务提交：
	commit;



三. repeatable read（可重读）---MySQL默认的隔离级别
	当我们将当前会话的隔离级别设置为repeatable read的时候，当前会话可以重复读，
	就是每次读取的结果集都相同，
	而不管其他事务有没有提交



四. serializable（串行化）
	结论四：
	当我们将当前会话的隔离级别设置为serializable的时候，
	其他会话对该表的写操作将被挂起。
	可以看到，这是隔离级别中最严格的，
	但是这样做势必对性能造成影响。
	所以在实际的选用上，
	我们要根据当前具体的情况选用合适的。








