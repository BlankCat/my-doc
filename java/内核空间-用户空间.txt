


整个计算机资源是有限的

内核态(内核空间)和用户态(用户空间)的区别和联系？
http://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html
http://www.cjjjs.com/paper/czxt/625201519722538.aspx
cpu分为 4个环
linux分为用户空间，和内核空间
0  1  2  3 ， 0=内和空间，   3=用户空间  1,2历史原因没有使用 

内核空间控制硬件，所有操作硬件都会进行 上下文切换
从用户空间切换到内核空间，使用协同调用，然后请求内核完成硬件操作后，将结果返回给用户空间程序



内核态与用户态是操作系统的两种运行级别
	Intel x86架构提供Ring0-Ring3四种级别的运行模式，
	Ring0级别最高，
	Ring3最低。
	Linux使用了Ring3级别运行用户态，
	Ring0作为 内核态，
	没有使用Ring1和Ring2。
	Ring3状态不能访问Ring0的地址空间，包括代码和数据。
	程序特权级别的不同，其所拥有的权力也不同。



用户应用层序
	|
		——>API，命令接口
	|
使用程序（汇编，编译，编辑，shell）
	|
API函数（读，写，打开，关闭，绘图等）
	|
		——>系统调用接口
	|
操作系统内核（进程管理，存储管理，文件管理，设备管理）
	|
硬件系统（处理器，存储器，磁盘，终端，打印机）



用户应用程序，操作系统，硬件系统

操作系统
	用户态（实用程序，API函数）
	核心态（操作系统内核）




用户空间就是用户进程所在的内存区域，相对的，
系统空间就是操作系统占据的内存区域。
用户进程和系统进程的所有数据都在内存中。




谁来划分内存空间的呢？
	在电脑开机之前，内存就是一块原始的物理内存。
	什么也没有。
	开机加电，系统启动后，
	就对物理内存进行了划分。
	当然，这是系统的规定，
	物理内存条上并没有划分好的地址和空间范围。
	这些划分都是操作系统在逻辑上的划分。
	不同版本的操作系统划分的结果都是不一样的。


 为什么要划分用户空间和系统空间呢？
 	当然是有必要的。
 	操作系统的数据都是存放于系统空间的，
 	用户进程的数据是存放于用户空间的。

	分开存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性
	分开存放，管理上很方便，而更重要的是，将用户的数据和系统的数据隔离开，
			  就可以对两部分的数据的访问进行控制。

	确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统


	用户态的程序只能访问用户空间，而处于
	内核态的程序可以访问用户空间和内核空间


那么用户态和内核态有什么区别呢？
	内核态
		任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）
		此时处理器处于特权级最高的（0级）内核代码中执行
		进程处于内核态时，执行的内核代码会使用当前进程的内核栈。
		每个进程都有自己的内核栈。

	用户态
		当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。
		即此时处理器在特权级最低的（3级）用户代码中运行。



用户态切换到内核态的3种方式
a. 系统调用
	这是用户态进程主动要求切换到内核态的一种方式，
	用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，
	比如fork()实际上就是执行了一个创建新进程的系统调用。
	而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，
	例如Linux的int 80h中断。
b. 异常
	当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，
	这时会触发由当前运行进程切换到处理此异常的内核相关程序中，
	也就转到了内核态，比如缺页异常。
c. 外围设备的中断
	当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，
	这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，
	如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。
	比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。



























