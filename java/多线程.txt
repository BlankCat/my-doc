
http://www.cnblogs.com/wangdaijun/category/840830.html

java多线程同步synchronized——对象监视器

锁（lock）和监视器（monitor）有什么区别？
Java的多线程底层是如何工作的。
锁为实现监视器提供必要的支持。

锁说白了就就是多个线程操作资源临界区的时候用的 

高并发不是那么容易的，高并发的因素有很多
1， 程序，  2， 系统， 3， 带宽，  4， 缓冲区（内存）等等。


并发多线程情况下， 读的时候没有问题，写的时候是资源临界区的时候用到锁；
资源临界区，就是资源正在使用
同一个资源多个程序或多个线程同时修改 
等到锁释放，即可访问资源，就是修改资源变量的值
说白了就是多线程不能同时修改同一个资源

多线程并发编程

（2）Java代码-->字节码-->根据字节码执行对应的C/C++代码-->C/C++代码被编译成汇编语言-->和硬件电路交互

（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问
（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住


内核态(内核空间)和用户态(用户空间)的区别和联系？
http://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html
http://www.cjjjs.com/paper/czxt/625201519722538.aspx
cpu分为 4个环
linux分为用户空间，和内核空间
0  1  2  3 ， 0=内和空间，   3=用户空间  1,2历史原因没有使用 

内核空间控制硬件，所有操作硬件都会进行 上下文切换
从用户空间切换到内核空间，使用协同调用，然后请求内核完成硬件操作后，将结果返回给用户空间程序

加锁-->解锁,反复地在内核态和用户态之间进行切换




40、高并发、任务执行时间短的业务怎样使用线程池？
	并发不高、任务执行时间长的业务怎样使用线程池？
	并发高、业务执行时间长的业务怎样使用线程池？
1高并发，任务执行时间短的业务，线程池数可以设置cpu内核数+1，减少线程上下文切换
2并发不高，任务执行时间长的业务
	a业务时间集中在io操作上，io秘籍型任务，
	io操作并不占用cpu，所以cpu闲下来，
	可以加大线程池的数目，让cpu处理更多的业务

	b业务时间集中在计算操作上，计算密集型任务。
		线程池中的线程数设置得少一些，减少线程上下文的切换
		并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计
		是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置



多线程
用多线程只有一个目的，那就是更好的利用cpu的资源
（1）发挥多核CPU的优势
（2）防止阻塞
（3）便于建模，把一个大任务，分解成任务A，B，C


2、创建线程的方式
	（1）继承Thread类
	（2）实现Runnable接口

3、start()方法和run()方法的区别
	只有调用了start()方法，才会表现出多线程的特性
	不同线程的run()方法里面的代码交替执行。
	只是调用run()方法，那么代码还是同步执行的
	必须等待一个线程的run()方法里面的代码全部执行完毕之后，
	另外一个线程才可以执行其run()方法里面的代码


4、Runnable接口和Callable接口的区别
	Runnable接口中的run()方法的返回值是void，纯粹地去执行run()方法中的代码而已
	Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果

	Callable+Future/FutureTask却可以获取多线程运行的结果，
	可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务

5、CyclicBarrier和CountDownLatch的区别
	（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；
		 CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行
	（2）CyclicBarrier只能唤起一个任务，
		 CountDownLatch可以唤起多个任务
	（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了

6、volatile关键字的作用
	理解volatile关键字的作用的前提是要理解Java内存模型

	（1）多线程围绕可见性，原子性 两个特性展开，volatile关键字修饰的变量，保证了其在多线程之间的可见性，
		 即每次读取到volatile变量，一定是最新的数据
	（2）Java代码-->字节码-->根据字节码执行对应的C/C++代码-->C/C++代码被编译成汇编语言-->和硬件电路交互
		 获取更好jvm性能，就会对java指令进行排序，多线程下排序jvm指令会出现意想不到的结果，
		 使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率

7、什么是线程安全
	如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。
线程安全级别
	（1）不可变
		String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值
		要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用
	（2）绝对线程安全
		不管任何运行环境，调用着不需要额外的同步措施
		Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的
		java中绝对线程安全的类，比方说CopyOnWriteArrayList、CopyOnWriteArraySet
	（3）相对线程安全
		相对线程安全也就是我们通常意义上所说的线程安全
		像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此
		如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，
		99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制

	（4）线程非安全
		ArrayList、LinkedList、HashMap等都是线程非安全的类

8、Java中如何获取到线程dump文件(线程堆栈)
	（1）获取到线程的pid，可以通过使用jps命令，ps -ef | grep java
	（2）打印线程堆栈，可以通过使用jstack pid命令，kill -3 pid
	 Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈
9、一个线程如果出现了运行时异常会怎么样
	出现异常没有被捕获，线程停止执行
	线程持有某个对象的监视器，对象监视器会立即释放

10、如何在两个线程之间共享数据
	创建线程之间的共享对象，
	然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待
	阻塞队列BlockingQueue就是为线程之间共享数据而设计的


11、sleep方法和wait方法有什么区别
	sleep方法和wait方法都可以用来放弃CPU一定的时间
	不同点在于如果线程持有某个对象的监视器，
	sleep方法不会放弃这个对象的监视器，
	wait方法会放弃这个对象的监视器


12、生产者消费者模型的作用是什么
	提升整个系统的运行效率
	解耦

13、ThreadLocal有什么用
	ThreadLocal就是一种以空间换时间的做法
	每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap
	数据进行隔离，数据不共享，自然就没有线程安全方面的问题了

14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用
	这是JDK强制的，
	wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁

15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别
	wait()方法立即释放对象监视器，
	notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。

16、为什么要使用线程池
	避免频繁地创建和销毁线程，达到线程对象的重用
	灵活地控制并发的数目。

17、怎么检测一个线程是否持有对象监视器
	Thread类提供了一个holdsLock(Object obj)方法
	当且仅当对象obj的监视器被某条线程持有的时候才会返回true

18、synchronized和ReentrantLock的区别
	synchronized是和if、else、for、while一样的关键字
	ReentrantLock是类

	ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，
	可以被继承、可以有方法、可以有各种各样的类变量

19、ConcurrentHashMap的并发度是什么
	ConcurrentHashMap的并发度就是segment的大小，默认为16
	这意味着最多同时可以有16条线程操作ConcurrentHashMap

20、ReadWriteLock是什么
	ReadWriteLock是一个读写锁接口，
	ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离
	读锁是共享的，写锁是独占的
	读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。


21、FutureTask是什么
	FutureTask表示一个异步运算的任务
	FutureTask里面可以传入一个Callable的具体实现类，
	可以对这个异步运算的任务的结果进行
	等待获取、
	判断是否已经完成、
	取消任务等操作

22，Linux环境下如何查找哪个线程使用CPU最长
	（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过
	（2）top -H -p pid，顺序不能改变

23、Java编程写一个会导致死锁的程序





24、怎么唤醒一个阻塞的线程
	线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，
	可以中断线程，并且通过抛出InterruptedException来唤醒它

	如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，
	Java代码并没有办法直接接触到操作系统

25、不可变对象对多线程有什么帮助
	不可变对象不需要实行同步手段，提升代码执行效率

26、什么是多线程的上下文切换
	CPU控制权由一个已经正在运行的线程切换到
	另外一个就绪并等待获取CPU执行权的线程的过程。

27、如果你提交任务时，线程池队列已满，这时会发生什么
	LinkedBlockingQueue无界队列，可以继续添加任务到阻塞队列中等待执行
	ArrayBlockingQueue 有界队列，队列满了就会拒绝策略


28、Java中用到的线程调度算法是什么
	抢占式。
	一个线程用完CPU之后，操作系统会根据线程优先级、
	线程饥饿情况等数据
	算出一个总的优先级并分配下一个时间片给某个线程执行。

29、Thread.sleep(0)的作用是什么
	Thread.sleep(0)手动触发一次操作系统分配时间片的操作，
	这也是平衡CPU控制权的一种操作。


30、什么是自旋






31、什么是Java内存模型
	Java内存模型定义了一种多线程访问Java内存的规范
	（1）Java内存模型将内存分为了主内存和工作内存
		类的状态，也就是类之间共享的变量，是存储在主内存中的
		用到这些主内存中的变量的时候，从主内存里面拷贝一份到工作内存，
		操作都是自己工作内存的那一份，执行完毕，更新值到主内存


32、什么是CAS
	Compare and Swap
	内存值V、旧的预期值A、要修改的值B，
	当且仅当预期值A和内存值V相同时，
	才会将内存值修改为B并返回true，
	否则什么都不做并返回false


33、什么是乐观锁和悲观锁
（1）乐观锁
	对于并发间操作产生的线程安全问题持乐观状态

	竞争不总是会发生，因此它不需要持有锁，
	将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量

	如果失败则表示发生冲突，那么就应该有相应的重试逻辑


（2）悲观锁
	对于并发间操作产生的线程安全问题持悲观状态
	竞争总是会发生，因此每次对某资源进行操作时，
	都会持有一个独占的锁，就像synchronized，
	不管三七二十一，直接上了锁就操作资源了


34、什么是AQS
	AQS全称为AbstractQueuedSychronizer抽象队列同步器。

	java.util.concurrent的基础是CAS的话
	AQS就是整个Java并发包的核心了，
	ReentrantLock、CountDownLatch、Semaphore等等都用到了它

	AQS实际上以双向队列的形式连接所有的Entry
	ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列

	AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，
	开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。

35、单例模式的线程安全性
	（1）饿汉式单例模式的写法：线程安全
	（2）懒汉式单例模式的写法：非线程安全
	（3）双检锁单例模式的写法：线程安全


36、Semaphore有什么作用
	Semaphore就是一个信号量，它的作用是限制某段代码块的并发数
	Semaphore有一个构造函数，可以传入一个int型整数n，
	表示某段代码最多只有n个线程可以访问，如果超出了n，
	那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入

37、Hashtable的size()方法中明明只有一条语句"return count"，为什么还要做同步？
	（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问
	（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住




39、同步方法和同步块，哪个是更好的选择
同步的范围越少越好。
	StringBuffer，它是一个线程安全的类，
	自然最常用的append()方法是一个同步方法，
	我们写代码的时候会反复append字符串，
	这意味着要进行反复的加锁->解锁，这对性能不利

Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换


































概念不够明确
多线程：指的是这个程序（一个进程）运行时产生了不止一个线程

并行与并发：
并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。

并发：通过cpu调度算法，让用户看上去同时执行，
	  实际上从cpu操作层面不是真正的同时。
	  并发往往在场景中有公用的资源，
	  那么针对这个公用的资源往往产生瓶颈，
	  我们会用TPS或者QPS来反应这个系统的处理能力。

线程安全：执行一段代码，多个线程使用，经过线程调度，不会影响最终结果，就是线程安全的
	 线程不安全，就是多线程执行同一段代码，线程调度后，最终结果改变了。


同步：线程同步保证多线程访问公共资源线程安全。


线程的状态
每个对象都有的方法（机制）
基本线程类
高级多线程控制类


























